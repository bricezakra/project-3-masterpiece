{"ast":null,"code":"import { Vector3 } from 'math.gl';\nimport { GL } from '../constants';\nimport assert from '../utils/assert';\nimport primitiveIterator from '../iterators/primitive-iterator';\nimport { getPrimitiveModeType } from '../primitives/modes';\nimport { getPositions } from './get-attribute-from-geometry';\nexport default function computeVertexNormals(_ref) {\n  var mode = _ref.mode,\n      indices = _ref.indices,\n      attributes = _ref.attributes;\n  assert(getPrimitiveModeType(mode) === GL.TRIANGLES, 'TRIANGLES required');\n\n  var _getPositions = getPositions({\n    mode: mode,\n    indices: indices,\n    attributes: attributes\n  }),\n      positions = _getPositions.values;\n\n  var normals = new Float32Array(positions.length);\n  var vectorA = new Vector3();\n  var vectorB = new Vector3();\n  var vectorC = new Vector3();\n  var vectorCB = new Vector3();\n  var vectorAB = new Vector3();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = primitiveIterator({\n      mode: mode,\n      indices: indices,\n      attributes: attributes\n    })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var primitive = _step.value;\n      vectorA.fromArray(positions, primitive.i1 * 3);\n      vectorB.fromArray(positions, primitive.i2 * 3 + 3);\n      vectorC.fromArray(positions, primitive.i3 * 3 + 6);\n      vectorCB.subVectors(vectorC, vectorB);\n      vectorAB.subVectors(vectorA, vectorB);\n      var normal = vectorCB.cross(vectorAB);\n      normal.normalize();\n      var primitiveIndex = primitive.primitiveIndex;\n      normals[primitiveIndex * 9 + 0] = normal.x;\n      normals[primitiveIndex * 9 + 1] = normal.y;\n      normals[primitiveIndex * 9 + 2] = normal.z;\n      normals[primitiveIndex * 9 + 3] = normal.x;\n      normals[primitiveIndex * 9 + 4] = normal.y;\n      normals[primitiveIndex * 9 + 5] = normal.z;\n      normals[primitiveIndex * 9 + 6] = normal.x;\n      normals[primitiveIndex * 9 + 7] = normal.y;\n      normals[primitiveIndex * 9 + 8] = normal.z;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return normals;\n}","map":null,"metadata":{},"sourceType":"module"}