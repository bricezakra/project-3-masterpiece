{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport assert from '../utils/assert';\nimport { createTypedArrayFromAccessor } from './helpers/tile-3d-accessor-utils';\nimport { initializeHierarchy, traverseHierarchy } from './tile-3d-batch-table-hierarchy';\n\nvar defined = function defined(x) {\n  return x !== undefined;\n};\n\nvar clone = function clone(x) {\n  return x;\n};\n\nvar IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  extensions: true,\n  extras: true\n};\n\nvar Tile3DBatchTableParser = function () {\n  function Tile3DBatchTableParser(json, binary, featureCount) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Tile3DBatchTableParser);\n\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = this.json && this.json.extensions || {};\n    this._properties = {};\n\n    for (var propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  _createClass(Tile3DBatchTableParser, [{\n    key: \"getExtension\",\n    value: function getExtension(extensionName) {\n      return this.json && this.json.extensions && this.json.extensions[extensionName];\n    }\n  }, {\n    key: \"memorySizeInBytes\",\n    value: function memorySizeInBytes() {\n      return 0;\n    }\n  }, {\n    key: \"isClass\",\n    value: function isClass(batchId, className) {\n      this._checkBatchId(batchId);\n\n      assert(typeof className === 'string', className);\n\n      if (this._hierarchy) {\n        var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n          var classId = hierarchy.classIds[instanceIndex];\n          var instanceClass = hierarchy.classes[classId];\n          return instanceClass.name === className;\n        });\n        return defined(result);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isExactClass\",\n    value: function isExactClass(batchId, className) {\n      assert(typeof className === 'string', className);\n      return this.getExactClassName(batchId) === className;\n    }\n  }, {\n    key: \"getExactClassName\",\n    value: function getExactClassName(batchId) {\n      this._checkBatchId(batchId);\n\n      if (this._hierarchy) {\n        var classId = this._hierarchy.classIds[batchId];\n        var instanceClass = this._hierarchy.classes[classId];\n        return instanceClass.name;\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"hasProperty\",\n    value: function hasProperty(batchId, name) {\n      this._checkBatchId(batchId);\n\n      assert(typeof name === 'string', name);\n      return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n    }\n  }, {\n    key: \"getPropertyNames\",\n    value: function getPropertyNames(batchId, results) {\n      var _results;\n\n      this._checkBatchId(batchId);\n\n      results = defined(results) ? results : [];\n      results.length = 0;\n      var propertyNames = Object.keys(this._properties);\n\n      (_results = results).push.apply(_results, _toConsumableArray(propertyNames));\n\n      if (this._hierarchy) {\n        this._getPropertyNamesInHierarchy(batchId, results);\n      }\n\n      return results;\n    }\n  }, {\n    key: \"getProperty\",\n    value: function getProperty(batchId, name) {\n      this._checkBatchId(batchId);\n\n      assert(typeof name === 'string', name);\n\n      if (this._binaryProperties) {\n        var binaryProperty = this._binaryProperties[name];\n\n        if (defined(binaryProperty)) {\n          return this._getBinaryProperty(binaryProperty, batchId);\n        }\n      }\n\n      var propertyValues = this._properties[name];\n\n      if (defined(propertyValues)) {\n        return clone(propertyValues[batchId], true);\n      }\n\n      if (this._hierarchy) {\n        var hierarchyProperty = this._getHierarchyProperty(batchId, name);\n\n        if (defined(hierarchyProperty)) {\n          return hierarchyProperty;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(batchId, name, value) {\n      var featureCount = this.featureCount;\n\n      this._checkBatchId(batchId, featureCount);\n\n      assert(typeof name === 'string', name);\n\n      if (this._binaryProperties) {\n        var binaryProperty = this._binaryProperties[name];\n\n        if (binaryProperty) {\n          this._setBinaryProperty(binaryProperty, batchId, value);\n\n          return;\n        }\n      }\n\n      if (this._hierarchy) {\n        if (this._setHierarchyProperty(this, batchId, name, value)) {\n          return;\n        }\n      }\n\n      var propertyValues = this._properties[name];\n\n      if (!defined(propertyValues)) {\n        this._properties[name] = new Array(featureCount);\n        propertyValues = this._properties[name];\n      }\n\n      propertyValues[batchId] = clone(value, true);\n    }\n  }, {\n    key: \"_checkBatchId\",\n    value: function _checkBatchId(batchId) {\n      var valid = batchId >= 0 && batchId < this.featureCount;\n\n      if (!valid) {\n        throw new Error(\"batchId not in range [0, featureCount - 1].\");\n      }\n    }\n  }, {\n    key: \"_getBinaryProperty\",\n    value: function _getBinaryProperty(binaryProperty, index) {\n      return binaryProperty.unpack(binaryProperty.typedArray, index);\n    }\n  }, {\n    key: \"_setBinaryProperty\",\n    value: function _setBinaryProperty(binaryProperty, index, value) {\n      binaryProperty.pack(value, binaryProperty.typedArray, index);\n    }\n  }, {\n    key: \"_initializeBinaryProperties\",\n    value: function _initializeBinaryProperties() {\n      var binaryProperties = null;\n\n      for (var name in this._properties) {\n        var property = this._properties[name];\n\n        var binaryProperty = this._initializeBinaryProperty(name, property);\n\n        if (binaryProperty) {\n          binaryProperties = binaryProperties || {};\n          binaryProperties[name] = binaryProperty;\n        }\n      }\n\n      return binaryProperties;\n    }\n  }, {\n    key: \"_initializeBinaryProperty\",\n    value: function _initializeBinaryProperty(name, property) {\n      if ('byteOffset' in property) {\n        var tile3DAccessor = property;\n        assert(this.binary, \"Property \".concat(name, \" requires a batch table binary.\"));\n        assert(tile3DAccessor.type, \"Property \".concat(name, \" requires a type.\"));\n        var accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n        return {\n          typedArray: accessor.values,\n          componentCount: accessor.size,\n          unpack: accessor.unpacker,\n          pack: accessor.packer\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hasPropertyInHierarchy\",\n    value: function _hasPropertyInHierarchy(batchId, name) {\n      if (!this._hierarchy) {\n        return false;\n      }\n\n      var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instances = hierarchy.classes[classId].instances;\n        return defined(instances[name]);\n      });\n      return defined(result);\n    }\n  }, {\n    key: \"_getPropertyNamesInHierarchy\",\n    value: function _getPropertyNamesInHierarchy(batchId, results) {\n      traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instances = hierarchy.classes[classId].instances;\n\n        for (var name in instances) {\n          if (instances.hasOwnProperty(name)) {\n            if (results.indexOf(name) === -1) {\n              results.push(name);\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_getHierarchyProperty\",\n    value: function _getHierarchyProperty(batchId, name) {\n      var _this = this;\n\n      return traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instanceClass = hierarchy.classes[classId];\n        var indexInClass = hierarchy.classIndexes[instanceIndex];\n        var propertyValues = instanceClass.instances[name];\n\n        if (defined(propertyValues)) {\n          if (defined(propertyValues.typedArray)) {\n            return _this._getBinaryProperty(propertyValues, indexInClass);\n          }\n\n          return clone(propertyValues[indexInClass], true);\n        }\n\n        return null;\n      });\n    }\n  }, {\n    key: \"_setHierarchyProperty\",\n    value: function _setHierarchyProperty(batchTable, batchId, name, value) {\n      var _this2 = this;\n\n      var result = traverseHierarchy(this._hierarchy, batchId, function (hierarchy, instanceIndex) {\n        var classId = hierarchy.classIds[instanceIndex];\n        var instanceClass = hierarchy.classes[classId];\n        var indexInClass = hierarchy.classIndexes[instanceIndex];\n        var propertyValues = instanceClass.instances[name];\n\n        if (defined(propertyValues)) {\n          assert(instanceIndex === batchId, \"Inherited property \\\"\".concat(name, \"\\\" is read-only.\"));\n\n          if (defined(propertyValues.typedArray)) {\n            _this2._setBinaryProperty(propertyValues, indexInClass, value);\n          } else {\n            propertyValues[indexInClass] = clone(value, true);\n          }\n\n          return true;\n        }\n\n        return false;\n      });\n      return defined(result);\n    }\n  }]);\n\n  return Tile3DBatchTableParser;\n}();\n\nexport { Tile3DBatchTableParser as default };","map":null,"metadata":{},"sourceType":"module"}