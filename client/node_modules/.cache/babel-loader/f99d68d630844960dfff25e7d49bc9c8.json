{"ast":null,"code":"import { log } from '@deck.gl/core';\nexport function linearScale(domain, range, value) {\n  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];\n}\nexport function quantizeScale(domain, range, value) {\n  var domainRange = domain[1] - domain[0];\n\n  if (domainRange <= 0) {\n    log.warn('quantizeScale: invalid domain, returning range[0]')();\n    return range[0];\n  }\n\n  var step = domainRange / range.length;\n  var idx = Math.floor((value - domain[0]) / step);\n  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n  return range[clampIdx];\n}\nexport function getScale(domain, range, scaleFunction) {\n  function scale(value) {\n    return scaleFunction(domain, range, value);\n  }\n\n  scale.domain = function () {\n    return domain;\n  };\n\n  scale.range = function () {\n    return range;\n  };\n\n  return scale;\n}\nexport function getQuantizeScale(domain, range) {\n  return getScale(domain, range, quantizeScale);\n}\nexport function getLinearScale(domain, range) {\n  return getScale(domain, range, linearScale);\n}\n\nfunction ascending(a, b) {\n  return a - b;\n}\n\nfunction threshold(domain, fraction) {\n  var domainLength = domain.length;\n\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  var domainFraction = (domainLength - 1) * fraction;\n  var lowIndex = Math.floor(domainFraction);\n  var low = domain[lowIndex];\n  var high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a, x) {\n  var lo = 0;\n  var hi = a.length;\n\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  return lo;\n}\n\nfunction quantileScale(thresholds, range, value) {\n  return range[bisectRight(thresholds, value)];\n}\n\nexport function getQuantileScale(domain, range) {\n  var sortedDomain = domain.sort(ascending);\n  var i = 0;\n  var n = Math.max(1, range.length);\n  var thresholds = new Array(n - 1);\n\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedDomain, i / n);\n  }\n\n  return function (value) {\n    return quantileScale(thresholds, range, value);\n  };\n}\n\nfunction ordinalScale(domain, domainMap, range, value) {\n  var key = \"\".concat(value);\n  var d = domainMap.get(key);\n\n  if (d === undefined) {\n    d = domain.push(value);\n    domainMap.set(key, d);\n  }\n\n  return range[(d - 1) % range.length];\n}\n\nexport function getOrdinalScale(domain, range) {\n  var domainMap = new Map();\n  var uniqueDomain = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = domain[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var d = _step.value;\n      var key = \"\".concat(d);\n\n      if (!domainMap.has(key)) {\n        domainMap.set(key, uniqueDomain.push(d));\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return function (value) {\n    return ordinalScale(uniqueDomain, domainMap, range, value);\n  };\n}","map":null,"metadata":{},"sourceType":"module"}