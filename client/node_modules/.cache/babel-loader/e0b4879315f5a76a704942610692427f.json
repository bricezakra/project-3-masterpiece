{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Stats } from 'probe.gl';\nvar STAT_QUEUED_REQUESTS = 'Queued Requests';\nvar STAT_ACTIVE_REQUESTS = 'Active Requests';\nvar STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nvar STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nvar STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\nvar DEFAULT_PROPS = {\n  id: 'request-scheduler',\n  throttleRequests: true,\n  maxRequests: 6\n};\n\nvar RequestScheduler = function () {\n  function RequestScheduler() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, RequestScheduler);\n\n    this.props = _objectSpread({}, props, {}, DEFAULT_PROPS);\n    this.requestQueue = [];\n    this.activeRequestCount = 0;\n    this.stats = new Stats({\n      id: props.id\n    });\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n  }\n\n  _createClass(RequestScheduler, [{\n    key: \"scheduleRequest\",\n    value: function scheduleRequest(handle) {\n      var _this = this;\n\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return 0;\n      };\n\n      if (!this.props.throttleRequests) {\n        return Promise.resolve(handle);\n      }\n\n      var promise = new Promise(function (resolve, reject) {\n        _this.requestQueue.push({\n          handle: handle,\n          callback: callback,\n          resolve: resolve,\n          reject: reject\n        });\n      });\n\n      this._issueNewRequests();\n\n      return promise;\n    }\n  }, {\n    key: \"startRequest\",\n    value: function startRequest(handle) {\n      this.activeRequestCount++;\n    }\n  }, {\n    key: \"endRequest\",\n    value: function endRequest(handle) {\n      this.activeRequestCount--;\n\n      this._issueNewRequests();\n    }\n  }, {\n    key: \"trackRequestPromise\",\n    value: function trackRequestPromise(handle, promise) {\n      var _this2 = this;\n\n      this.startRequest(handle);\n      promise.then(function () {\n        return _this2.endRequest(handle);\n      })[\"catch\"](function () {\n        return _this2.endRequest(handle);\n      });\n    }\n  }, {\n    key: \"_issueNewRequests\",\n    value: function _issueNewRequests() {\n      var _this3 = this;\n\n      this._updateNeeded = true;\n      setTimeout(function () {\n        return _this3._issueNewRequestsAsync();\n      }, 0);\n    }\n  }, {\n    key: \"_issueNewRequestsAsync\",\n    value: function _issueNewRequestsAsync() {\n      this._updateNeeded = false;\n      var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n      if (freeSlots === 0) {\n        return;\n      }\n\n      this._updateAllRequests();\n\n      for (var i = 0; i < freeSlots; ++i) {\n        if (this.requestQueue.length > 0) {\n          var request = this.requestQueue.shift();\n          request.resolve(true);\n        }\n      }\n    }\n  }, {\n    key: \"_updateAllRequests\",\n    value: function _updateAllRequests() {\n      var requestQueue = this.requestQueue;\n\n      for (var i = 0; i < requestQueue.length; ++i) {\n        var request = requestQueue[i];\n\n        if (!this._updateRequest(request)) {\n          requestQueue.splice(i, 1);\n          i--;\n        }\n      }\n\n      requestQueue.sort(function (a, b) {\n        return a.priority - b.priority;\n      });\n    }\n  }, {\n    key: \"_updateRequest\",\n    value: function _updateRequest(request) {\n      request.priority = request.callback(request.handle);\n\n      if (request.priority < 0) {\n        request.resolve(false);\n        return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return RequestScheduler;\n}();\n\nexport { RequestScheduler as default };","map":null,"metadata":{},"sourceType":"module"}