{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { TILE3D_REFINEMENT } from '../constants';\nimport ManagedArray from '../utils/managed-array';\nimport assert from '../utils/assert';\n\nvar Tileset3DTraverser = function () {\n  function Tileset3DTraverser() {\n    _classCallCheck(this, Tileset3DTraverser);\n\n    this.traversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n    this.emptyTraversal = {\n      stack: new ManagedArray(),\n      stackMaximumLength: 0\n    };\n    this.result = {\n      _requestedTiles: [],\n      selectedTiles: [],\n      _emptyTiles: [],\n      _hasMixedContent: false\n    };\n    this._disableSkipLevelOfDetail = false;\n  }\n\n  _createClass(Tileset3DTraverser, [{\n    key: \"traverse\",\n    value: function traverse(root, frameState, options) {\n      this.root = root;\n      this.options = options;\n      this.result._requestedTiles.length = 0;\n      this.result.selectedTiles.length = 0;\n      this.result._emptyTiles.length = 0;\n      this.result._hasMixedContent = false;\n      this.updateTile(root, frameState);\n\n      if (!root.isVisibleAndInRequestVolume) {\n        return false;\n      }\n\n      if (root.getScreenSpaceError(frameState, true) <= options.maximumScreenSpaceError) {\n        return false;\n      }\n\n      var baseScreenSpaceError = options.maximumScreenSpaceError;\n      this.executeTraversal(root, baseScreenSpaceError, frameState);\n      this.traversal.stack.trim(this.traversal.stackMaximumLength);\n      this.emptyTraversal.stack.trim(this.emptyTraversal.stackMaximumLength);\n      return true;\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile, frameState) {\n      tile._selectedFrame = frameState.frameNumber;\n      this.result.selectedTiles.push(tile);\n    }\n  }, {\n    key: \"selectDesiredTile\",\n    value: function selectDesiredTile(tile, frameState) {\n      if (!this.options.skipLevelOfDetail) {\n        if (tile.contentAvailable) {\n          this.selectTile(tile, frameState);\n        }\n\n        return;\n      }\n\n      var loadedTile = tile.contentAvailable ? tile : tile._ancestorWithContentAvailable;\n\n      if (loadedTile) {\n        loadedTile._shouldSelect = true;\n      } else {\n        this.selectDescendants(tile, frameState);\n      }\n    }\n  }, {\n    key: \"visitTile\",\n    value: function visitTile(tileset, tile, frameState) {\n      ++tileset._statistics.visited;\n      tile._visitedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"touchTile\",\n    value: function touchTile(tile, frameState) {\n      tile.tileset._cache.touch(tile);\n\n      tile._touchedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"getPriority\",\n    value: function getPriority(tile, options) {\n      switch (tile.refine) {\n        case TILE3D_REFINEMENT.ADD:\n          return tile._distanceToCamera;\n\n        case TILE3D_REFINEMENT.REPLACE:\n          var parent = tile.parent;\n          var useParentScreenSpaceError = parent && (!options.skipLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent);\n          var screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;\n          var rootScreenSpaceError = this.root._screenSpaceError;\n          return rootScreenSpaceError - screenSpaceError;\n\n        default:\n          return assert(false);\n      }\n    }\n  }, {\n    key: \"loadTile\",\n    value: function loadTile(tile, frameState) {\n      if (tile.hasUnloadedContent || tile.contentExpired) {\n        tile._requestedFrame = frameState.frameNumber;\n        tile._priority = this.getPriority(tile, this.options);\n\n        this.result._requestedTiles.push(tile);\n      }\n    }\n  }, {\n    key: \"updateTileVisibility\",\n    value: function updateTileVisibility(tile, frameState) {\n      tile.updateVisibility(frameState);\n    }\n  }, {\n    key: \"updateTile\",\n    value: function updateTile(tile, frameState) {\n      this.updateTileVisibility(tile, frameState);\n      tile.updateExpiration();\n    }\n  }, {\n    key: \"updateAndPushChildren\",\n    value: function updateAndPushChildren(tile, stack, frameState) {\n      var children = tile.children;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          this.updateTile(child, frameState);\n          stack.push(child);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"canTraverse\",\n    value: function canTraverse(tile, options) {\n      if (tile.children.length === 0 || options.depthLimit < tile.depth) {\n        return false;\n      }\n\n      if (tile.hasTilesetContent) {\n        return !tile.contentExpired;\n      }\n\n      return tile._screenSpaceError > options.maximumScreenSpaceError;\n    }\n  }, {\n    key: \"executeTraversal\",\n    value: function executeTraversal(root, baseScreenSpaceError, frameState) {\n      var traversal = this.traversal;\n      var stack = traversal.stack;\n      stack.push(root);\n\n      while (stack.length > 0) {\n        traversal.stackMaximumLength = Math.max(traversal.stackMaximumLength, stack.length);\n        var tile = stack.pop();\n        var add = tile.refine === TILE3D_REFINEMENT.ADD;\n        var replace = tile.refine === TILE3D_REFINEMENT.REPLACE;\n        var parent = tile.parent;\n        var parentRefines = !parent || parent._refines;\n        var refines = false;\n\n        if (this.canTraverse(tile, this.options)) {\n          refines = this.updateAndPushChildren(tile, stack, frameState) && parentRefines;\n        }\n\n        var stoppedRefining = !refines && parentRefines;\n\n        if (!tile.hasRenderContent) {\n          this.result._emptyTiles.push(tile);\n\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectDesiredTile(tile, frameState);\n          }\n        } else if (add) {\n          this.loadTile(tile, frameState);\n          this.selectDesiredTile(tile, frameState);\n        } else if (replace) {\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectDesiredTile(tile, frameState);\n          }\n        }\n\n        this.touchTile(tile, frameState);\n        tile._refines = refines;\n      }\n    }\n  }]);\n\n  return Tileset3DTraverser;\n}();\n\nexport { Tileset3DTraverser as default };","map":null,"metadata":{},"sourceType":"module"}