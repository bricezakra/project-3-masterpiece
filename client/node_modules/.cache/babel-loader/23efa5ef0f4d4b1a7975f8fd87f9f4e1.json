{"ast":null,"code":"import _readOnlyError from \"@babel/runtime/helpers/esm/readOnlyError\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { Vector3, Matrix3, Matrix4, degrees } from 'math.gl';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport assert from '../../utils/assert';\n\nvar defined = function defined(x) {\n  return x !== undefined;\n};\n\nvar scratchMatrix = new Matrix3();\nvar scratchScale = new Vector3();\nvar scratchCenter = new Vector3();\nvar scratchTransform = new Matrix4();\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n\n  if (boundingVolumeHeader.region) {\n    var _boundingVolumeHeader = _slicedToArray(boundingVolumeHeader.region, 6),\n        west = _boundingVolumeHeader[0],\n        south = _boundingVolumeHeader[1],\n        east = _boundingVolumeHeader[2],\n        north = _boundingVolumeHeader[3],\n        minHeight = _boundingVolumeHeader[4],\n        maxHeight = _boundingVolumeHeader[5];\n\n    var center = new Vector3(degrees((west + east) / 2), degrees((north + south) / 2), (minHeight + maxHeight) / 2);\n    var centerInCartesian = Ellipsoid.WGS84.cartographicToCartesian(center, scratchCenter);\n    var northWest = Ellipsoid.WGS84.cartographicToCartesian([north, west, 0]);\n    var northEast = Ellipsoid.WGS84.cartographicToCartesian([north, east, 0]);\n    var southWest = Ellipsoid.WGS84.cartographicToCartesian([south, west, 0]);\n    var radius = (Math.abs(northEast[0] - northWest[0]) + Math.abs(southWest[1] - northWest[1])) * 8;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  var center = new Vector3(box[0], box[1], box[2]);\n  var halfAxes = new Matrix3(box.slice(3, box.length));\n  transform.transform(center, center);\n  halfAxes = new Matrix3(transform[0], transform[1], transform[2], transform[4], transform[5], transform[6], transform[8], transform[9], transform[10]).multiplyRight(halfAxes);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  var rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  var minimumHeight = region[4];\n  var maximumHeight = region[5];\n  var orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, Ellipsoid.WGS84, scratchOrientedBoundingBox);\n  var center = orientedBoundingBox.center;\n  var halfAxes = orientedBoundingBox.halfAxes;\n  transform = Matrix4.multiplyTransformation(transform, Matrix4.inverseTransformation(initialTransform, scratchTransform), scratchTransform);\n  center = (_readOnlyError(\"center\"), Matrix4.multiplyByPoint(transform, center, center));\n  var rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = (_readOnlyError(\"halfAxes\"), Matrix3.multiply(rotationScale, halfAxes, halfAxes));\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  var rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n\nfunction createSphere(sphere, transform, result) {\n  var center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  var scale = transform.getScale(scratchScale);\n  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  var radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}","map":null,"metadata":{},"sourceType":"module"}