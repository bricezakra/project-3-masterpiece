{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix4 } from 'math.gl';\nimport { CullingVolume } from '@math.gl/culling';\nimport { parse, fetchFile, path } from '@loaders.gl/core';\nimport Tile3DLoader from '../tile-3d-loader';\nimport Tileset3DLoader from '../tileset-3d-loader';\nimport { TILE3D_REFINEMENT, TILE3D_CONTENT_STATE, TILE3D_OPTIMIZATION_HINT } from '../constants';\nimport assert from '../utils/assert';\nimport { createBoundingVolume } from './helpers/bounding-volume';\n\nvar defined = function defined(x) {\n  return x !== undefined && x !== null;\n};\n\nvar scratchDate = new Date();\nvar scratchCommandList = [];\nvar scratchToTileCenter = new Vector3();\nvar scratchPlane = new Plane();\nimport { INTERSECT, Intersect, Plane } from '@math.gl/culling';\n\nfunction computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentPlaneMask) {\n  assert(boundingVolume, 'boundingVolume is required.');\n  assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n  if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n    return parentPlaneMask;\n  }\n\n  var mask = CullingVolume.MASK_INSIDE;\n  var planes = cullingVolume.planes;\n\n  for (var k = 0; k < cullingVolume.planes.length; ++k) {\n    var flag = k < 31 ? 1 << k : 0;\n\n    if (k < 31 && (parentPlaneMask & flag) === 0) {\n      continue;\n    }\n\n    var plane = scratchPlane.fromNormalDistance(planes[k].normal, planes[k].distance);\n    var result = boundingVolume.intersectPlane(plane);\n\n    if (result === Intersect.OUTSIDE) {\n      return CullingVolume.MASK_OUTSIDE;\n    } else if (result === Intersect.INTERSECTING) {\n      mask |= flag;\n    }\n  }\n\n  return mask;\n}\n\nvar Tile3DHeader = function () {\n  function Tile3DHeader(tileset, header, parentHeader, basePath) {\n    _classCallCheck(this, Tile3DHeader);\n\n    assert(_typeof(header) === 'object');\n    this._tileset = tileset;\n    this._header = header;\n    this._basePath = basePath;\n    this._content = null;\n    this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n    this._gpuMemoryUsageInBytes = 0;\n    this.parent = parentHeader;\n    this.children = [];\n    this.refine = this._getRefine(header.refine);\n    this.cacheNode = undefined;\n    this.userData = {};\n\n    if ('geometricError' in header) {\n      this.geometricError = header.geometricError;\n    } else {\n      this.geometricError = this.parent && this.parent.geometricError || tileset.geometricError;\n      console.warn('3D Tile: Required prop geometricError is undefined. Using parent error');\n    }\n\n    this._initializeTransforms(header);\n\n    this._initializeBoundingVolumes(header);\n\n    this._initializeContent(header);\n\n    this._initializeCache(header);\n\n    this._optimChildrenWithinParent = TILE3D_OPTIMIZATION_HINT.NOT_COMPUTED;\n\n    this._initializeRenderingState();\n\n    Object.seal(this);\n  }\n\n  _createClass(Tile3DHeader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._header = null;\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this._header === null;\n    }\n  }, {\n    key: \"getScreenSpaceError\",\n    value: function getScreenSpaceError(frameState, useParentGeometricError) {\n      var tileset = this._tileset;\n      var parentGeometricError = this.parent && this.parent.geometricError || tileset.geometricError;\n      var geometricError = useParentGeometricError ? parentGeometricError : this.geometricError;\n\n      if (geometricError === 0.0) {\n        return 0.0;\n      }\n\n      var distance = Math.max(this._distanceToCamera, 1e-7);\n      var height = frameState.height,\n          sseDenominator = frameState.sseDenominator;\n      var error = geometricError * height / (distance * sseDenominator);\n      error -= this._getDynamicScreenSpaceError(distance);\n      return error;\n    }\n  }, {\n    key: \"_getDynamicScreenSpaceError\",\n    value: function _getDynamicScreenSpaceError(distance) {\n      function fog(distanceToCamera, density) {\n        var scalar = distanceToCamera * density;\n        return 1.0 - Math.exp(-(scalar * scalar));\n      }\n\n      var tileset = this._tileset;\n\n      if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n        var density = tileset._dynamicScreenSpaceErrorComputedDensity;\n        var factor = tileset.dynamicScreenSpaceErrorFactor;\n        var dynamicError = fog(distance, density) * factor;\n        return dynamicError;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"loadContent\",\n    value: function () {\n      var _loadContent = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var expired, updatePriority, cancelled, contentUri, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                updatePriority = function _ref(tile) {\n                  if (!tile._visible) {\n                    return -1;\n                  }\n\n                  if (tile._contentState === TILE3D_CONTENT_STATE.UNLOADED) {\n                    return -1;\n                  }\n\n                  return Math.max(1e7 - tile._priority, 0) || 0;\n                };\n\n                if (!this.hasEmptyContent) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 3:\n                if (!this._content) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", true);\n\n              case 5:\n                expired = this.contentExpired;\n\n                if (expired) {\n                  this.expireDate = undefined;\n                }\n\n                this._contentState = TILE3D_CONTENT_STATE.LOADING;\n                _context.next = 10;\n                return this.tileset._requestScheduler.scheduleRequest(this, updatePriority);\n\n              case 10:\n                cancelled = !_context.sent;\n\n                if (!cancelled) {\n                  _context.next = 14;\n                  break;\n                }\n\n                this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n                return _context.abrupt(\"return\", false);\n\n              case 14:\n                _context.prev = 14;\n                contentUri = this.uri;\n                _context.prev = 16;\n\n                this.tileset._requestScheduler.startRequest(this);\n\n                _context.next = 20;\n                return fetchFile(contentUri, this.tileset.options.fetchOptions);\n\n              case 20:\n                response = _context.sent;\n\n              case 21:\n                _context.prev = 21;\n\n                this.tileset._requestScheduler.endRequest(this);\n\n                return _context.finish(21);\n\n              case 24:\n                _context.next = 26;\n                return parse(response, [Tile3DLoader, Tileset3DLoader]);\n\n              case 26:\n                this._content = _context.sent;\n\n                if (contentUri.indexOf('.json') !== -1) {\n                  this._tileset._initializeTileHeaders(this._content, this, path.dirname(this.uri));\n                }\n\n                this._contentState = TILE3D_CONTENT_STATE.READY;\n\n                this._contentLoaded();\n\n                return _context.abrupt(\"return\", true);\n\n              case 33:\n                _context.prev = 33;\n                _context.t0 = _context[\"catch\"](14);\n                this._contentState = TILE3D_CONTENT_STATE.FAILED;\n                throw _context.t0;\n\n              case 37:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[14, 33], [16,, 21, 24]]);\n      }));\n\n      function loadContent() {\n        return _loadContent.apply(this, arguments);\n      }\n\n      return loadContent;\n    }()\n  }, {\n    key: \"unloadContent\",\n    value: function unloadContent() {\n      if (!this.hasRenderContent) {\n        return false;\n      }\n\n      if (this._content && this._content.destroy) {\n        this._content.destroy();\n      }\n\n      this._content = null;\n      this._contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      return true;\n    }\n  }, {\n    key: \"updateVisibility\",\n    value: function updateVisibility(frameState) {\n      var tileset = this._tileset;\n\n      if (this._updatedVisibilityFrame === tileset._updatedVisibilityFrame) {\n        return;\n      }\n\n      var parent = this.parent;\n      var parentTransform = parent ? parent.computedTransform : this._tileset.modelMatrix;\n      var parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;\n\n      this._updateTransform(parentTransform);\n\n      this._distanceToCamera = this.distanceToTile(frameState);\n      this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);\n      this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n      this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n      this._updatedVisibilityFrame = tileset._updatedVisibilityFrame;\n    }\n  }, {\n    key: \"updateExpiration\",\n    value: function updateExpiration() {\n      if (defined(this.expireDate) && this.contentReady && !this.hasEmptyContent) {\n        var now = Date.now(scratchDate);\n\n        if (Date.lessThan(this.expireDate, now)) {\n          this._contentState = TILE3D_CONTENT_STATE.EXPIRED;\n          this._expiredContent = this._content;\n        }\n      }\n    }\n  }, {\n    key: \"visibility\",\n    value: function visibility(frameState, parentVisibilityPlaneMask) {\n      var cullingVolume = frameState.cullingVolume;\n      var boundingVolume = this.boundingVolume,\n          tileset = this.tileset;\n      var clippingPlanes = tileset.clippingPlanes,\n          clippingPlanesOriginMatrix = tileset.clippingPlanesOriginMatrix;\n\n      if (clippingPlanes && clippingPlanes.enabled) {\n        var intersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume, clippingPlanesOriginMatrix);\n        this._isClipped = intersection !== Intersect.INSIDE;\n\n        if (intersection === Intersect.OUTSIDE) {\n          return CullingVolume.MASK_OUTSIDE;\n        }\n      }\n\n      return computeVisibilityWithPlaneMask(cullingVolume, boundingVolume, parentVisibilityPlaneMask);\n    }\n  }, {\n    key: \"contentVisibility\",\n    value: function contentVisibility(frameState) {\n      return true;\n    }\n  }, {\n    key: \"distanceToTile\",\n    value: function distanceToTile(frameState) {\n      var boundingVolume = this._boundingVolume;\n      return Math.sqrt(boundingVolume.distanceSquaredTo(frameState.camera.position));\n    }\n  }, {\n    key: \"cameraSpaceZDepth\",\n    value: function cameraSpaceZDepth(_ref2) {\n      var camera = _ref2.camera;\n      var boundingVolume = this.boundingVolume;\n      scratchToTileCenter.subVectors(boundingVolume.center, camera.position);\n      return camera.direction.dot(scratchToTileCenter);\n    }\n  }, {\n    key: \"insideViewerRequestVolume\",\n    value: function insideViewerRequestVolume(frameState) {\n      var viewerRequestVolume = this._viewerRequestVolume;\n      return !viewerRequestVolume || viewerRequestVolume.distanceToCamera(frameState) === 0.0;\n    }\n  }, {\n    key: \"_initializeCache\",\n    value: function _initializeCache(header) {\n      this.cacheNode = undefined;\n      var expire = header.expire;\n      var expireDuration;\n      var expireDate;\n\n      if (expire) {\n        expireDuration = expire.duration;\n\n        if (expire.date) {\n          expireDate = Date.fromIso8601(expire.date);\n        }\n      }\n\n      this.expireDuration = expireDuration;\n      this.expireDate = expireDate;\n    }\n  }, {\n    key: \"_initializeTransforms\",\n    value: function _initializeTransforms(tileHeader) {\n      this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n      var parent = this.parent;\n      var tileset = this._tileset;\n      var parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();\n      this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n      var parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n      this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n    }\n  }, {\n    key: \"_initializeBoundingVolumes\",\n    value: function _initializeBoundingVolumes(tileHeader) {\n      this._boundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n      this._contentBoundingVolume = null;\n      this._viewerRequestVolume = null;\n\n      if (tileHeader.content && tileHeader.content.boundingVolume) {\n        this._contentBoundingVolume = createBoundingVolume(tileHeader.boundingVolume, this.computedTransform);\n      }\n\n      if (tileHeader.viewerRequestVolume) {\n        this._viewerRequestVolume = createBoundingVolume(tileHeader.viewerRequestVolume, this.computedTransform);\n      }\n    }\n  }, {\n    key: \"_initializeContent\",\n    value: function _initializeContent(tileHeader) {\n      this._content = {\n        _tileset: this._tileset,\n        _tile: this\n      };\n      this.hasEmptyContent = true;\n      this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n      this._expiredContent = undefined;\n      this._serverKey = null;\n      this.hasTilesetContent = false;\n\n      if (tileHeader.content) {\n        this.contentUri = tileHeader.content.uri || tileHeader.content.url;\n\n        if ('url' in tileHeader) {\n          console.warn('Tileset 3D: \"content.url\" property deprecated. Use \"content.uri\" instead.');\n          this.contentUri = tileHeader.url;\n        }\n\n        this._content = null;\n        this.hasEmptyContent = false;\n        this.contentState = TILE3D_CONTENT_STATE.UNLOADED;\n        this.fullUri = this._basePath + '/' + this.contentUri;\n      }\n    }\n  }, {\n    key: \"_initializeRenderingState\",\n    value: function _initializeRenderingState() {\n      this._distanceToCamera = 0;\n      this._centerZDepth = 0;\n      this._screenSpaceError = 0;\n      this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n      this._visible = false;\n      this._inRequestVolume = false;\n      this._finalResolution = true;\n      this._depth = 0;\n      this._stackLength = 0;\n      this._selectionDepth = 0;\n      this._updatedVisibilityFrame = 0;\n      this._touchedFrame = 0;\n      this._visitedFrame = 0;\n      this._selectedFrame = 0;\n      this._requestedFrame = 0;\n      this._ancestorWithContent = undefined;\n      this._ancestorWithContentAvailable = undefined;\n      this._refines = false;\n      this._shouldSelect = false;\n      this._priority = 0.0;\n    }\n  }, {\n    key: \"_getRefine\",\n    value: function _getRefine(refine) {\n      switch (refine) {\n        case 'REPLACE':\n        case 'replace':\n          return TILE3D_REFINEMENT.REPLACE;\n\n        case 'ADD':\n        case 'add':\n          return TILE3D_REFINEMENT.ADD;\n\n        default:\n          return this.parent ? this.parent.refine : TILE3D_REFINEMENT.REPLACE;\n      }\n    }\n  }, {\n    key: \"_isTileset\",\n    value: function _isTileset(content) {\n      return Boolean(content.asset);\n    }\n  }, {\n    key: \"_contentLoaded\",\n    value: function _contentLoaded() {\n      switch (this._content && this._content.type) {\n        case 'vctr':\n        case 'geom':\n          tileset.traverser.disableSkipLevelOfDetail = true;\n\n        default:\n      }\n\n      if (this._isTileset(this._content)) {\n        this.hasTilesetContent = true;\n      }\n    }\n  }, {\n    key: \"_updateTransform\",\n    value: function _updateTransform() {\n      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix4();\n      var computedTransform = parentTransform.clone().multiplyRight(this.transform);\n      var didTransformChange = !computedTransform.equals(this.computedTransform);\n\n      if (!didTransformChange) {\n        return;\n      }\n\n      this.computedTransform = computedTransform;\n      var header = this._header;\n      var content = this._header.content;\n      this._boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this._boundingVolume);\n\n      if (this._contentBoundingVolume) {\n        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n      }\n\n      if (this._viewerRequestVolume) {\n        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n      }\n    }\n  }, {\n    key: \"gpuMemoryUsageInBytes\",\n    get: function get() {\n      return this._gpuMemoryUsageInBytes;\n    }\n  }, {\n    key: \"tileset\",\n    get: function get() {\n      return this._tileset;\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this._depth;\n    }\n  }, {\n    key: \"selectedFrame\",\n    get: function get() {\n      return this._selectedFrame;\n    }\n  }, {\n    key: \"isVisibleAndInRequestVolume\",\n    get: function get() {\n      return this._visible && this._inRequestVolume;\n    }\n  }, {\n    key: \"content\",\n    get: function get() {\n      return this._content;\n    }\n  }, {\n    key: \"contentReady\",\n    get: function get() {\n      return this._contentState === TILE3D_CONTENT_STATE.READY;\n    }\n  }, {\n    key: \"hasRenderContent\",\n    get: function get() {\n      return !this.hasEmptyContent && !this.hasTilesetContent;\n    }\n  }, {\n    key: \"contentAvailable\",\n    get: function get() {\n      return this.contentReady && this.hasRenderContent || defined(this._expiredContent) && !this.contentFailed;\n    }\n  }, {\n    key: \"hasUnloadedContent\",\n    get: function get() {\n      return this.hasRenderContent && this.contentUnloaded;\n    }\n  }, {\n    key: \"contentUnloaded\",\n    get: function get() {\n      return this._contentState === TILE3D_CONTENT_STATE.UNLOADED;\n    }\n  }, {\n    key: \"contentExpired\",\n    get: function get() {\n      return this._contentState === TILE3D_CONTENT_STATE.EXPIRED;\n    }\n  }, {\n    key: \"contentFailed\",\n    get: function get() {\n      return this._contentState === TILE3D_CONTENT_STATE.FAILED;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this.tileset.getTileUrl(this.contentUri, this._basePath);\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this.tileset.getTileUrl(this.contentUri, this._basePath);\n    }\n  }, {\n    key: \"boundingVolume\",\n    get: function get() {\n      return this._boundingVolume;\n    }\n  }, {\n    key: \"contentBoundingVolume\",\n    get: function get() {\n      return this._contentBoundingVolume || this._boundingVolume;\n    }\n  }, {\n    key: \"boundingSphere\",\n    get: function get() {\n      return this._boundingVolume.boundingSphere;\n    }\n  }, {\n    key: \"extras\",\n    get: function get() {\n      return this._header.extras;\n    }\n  }]);\n\n  return Tile3DHeader;\n}();\n\nexport { Tile3DHeader as default };\n\nfunction updateContent(tile, tileset, frameState) {\n  var content = tile._content;\n  var expiredContent = tile._expiredContent;\n\n  if (expiredContent) {\n    if (!tile.contentReady) {\n      expiredContent.update(tileset, frameState);\n      return;\n    }\n\n    tile._expiredContent.destroy();\n\n    tile._expiredContent = undefined;\n  }\n\n  content.update(tileset, frameState);\n}\n\nfunction updateExpireDate(tile) {\n  if (defined(tile.expireDuration)) {\n    var expireDurationDate = Date.now(scratchDate);\n    Date.addSeconds(expireDurationDate, tile.expireDuration, expireDurationDate);\n\n    if (defined(tile.expireDate)) {\n      if (Date.lessThan(tile.expireDate, expireDurationDate)) {\n        Date.clone(expireDurationDate, tile.expireDate);\n      }\n    } else {\n      tile.expireDate = Date.clone(expireDurationDate);\n    }\n  }\n}\n\nfunction createPriorityFunction(tile) {\n  return function () {\n    return tile._priority;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}