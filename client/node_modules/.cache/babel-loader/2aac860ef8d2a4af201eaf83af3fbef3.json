{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Vector4, assert } from 'math.gl';\nimport { Intersect } from '../constants';\nimport Plane from './plane';\nvar faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nvar scratchPlaneCenter = new Vector3();\nvar scratchPlaneNormal = new Vector3();\nvar scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\nvar CullingVolume = function () {\n  _createClass(CullingVolume, null, [{\n    key: \"MASK_OUTSIDE\",\n    get: function get() {\n      return 0xffffffff;\n    }\n  }, {\n    key: \"MASK_INSIDE\",\n    get: function get() {\n      return 0x00000000;\n    }\n  }, {\n    key: \"MASK_INDETERMINATE\",\n    get: function get() {\n      return 0x7fffffff;\n    }\n  }]);\n\n  function CullingVolume() {\n    var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, CullingVolume);\n\n    this.planes = planes;\n    assert(this.planes.every(function (plane) {\n      return plane instanceof Plane;\n    }));\n  }\n\n  _createClass(CullingVolume, [{\n    key: \"fromBoundingSphere\",\n    value: function fromBoundingSphere(boundingSphere) {\n      this.planes.length = 2 * faces.length;\n      var center = boundingSphere.center;\n      var radius = boundingSphere.radius;\n      var planeIndex = 0;\n\n      for (var _i = 0, _faces = faces; _i < _faces.length; _i++) {\n        var faceNormal = _faces[_i];\n        var plane0 = this.planes[planeIndex];\n        var plane1 = this.planes[planeIndex + 1];\n\n        if (!plane0) {\n          plane0 = this.planes[planeIndex] = new Vector4();\n        }\n\n        if (!plane1) {\n          plane1 = this.planes[planeIndex + 1] = new Vector4();\n        }\n\n        var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n        var plane0Distance = -faceNormal.dot(plane0Center);\n        plane0.x = faceNormal.x;\n        plane0.y = faceNormal.y;\n        plane0.z = faceNormal.z;\n        plane0.w = plane0Distance;\n        var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n        var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n        var plane1Distance = -negatedFaceNormal.dot(plane1Center);\n        plane1.x = negatedFaceNormal.x;\n        plane1.y = negatedFaceNormal.y;\n        plane1.z = negatedFaceNormal.z;\n        plane1.w = plane1Distance;\n        planeIndex += 2;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"computeVisibility\",\n    value: function computeVisibility(boundingVolume) {\n      assert(boundingVolume);\n      var intersect = Intersect.INSIDE;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.planes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var planeCoefficients = _step.value;\n          var plane = scratchPlane.fromCoefficients.apply(scratchPlane, _toConsumableArray(planeCoefficients));\n          var result = boundingVolume.intersectPlane(plane);\n\n          switch (result) {\n            case Intersect.OUTSIDE:\n              return Intersect.OUTSIDE;\n\n            case Intersect.INTERSECTING:\n              intersect = Intersect.INTERSECTING;\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return intersect;\n    }\n  }, {\n    key: \"computeVisibilityWithPlaneMask\",\n    value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n      assert(boundingVolume, 'boundingVolume is required.');\n      assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n        return parentPlaneMask;\n      }\n\n      var mask = CullingVolume.MASK_INSIDE;\n      var planes = this.planes;\n\n      for (var k = 0; k < this.planes.length; ++k) {\n        var flag = k < 31 ? 1 << k : 0;\n\n        if (k < 31 && (parentPlaneMask & flag) === 0) {\n          continue;\n        }\n\n        var plane = scratchPlane.fromCoefficients.apply(scratchPlane, _toConsumableArray(planes[k]));\n        var result = boundingVolume.intersectPlane(plane);\n\n        if (result === Intersect.OUTSIDE) {\n          return CullingVolume.MASK_OUTSIDE;\n        } else if (result === Intersect.INTERSECTING) {\n          mask |= flag;\n        }\n      }\n\n      return mask;\n    }\n  }]);\n\n  return CullingVolume;\n}();\n\nexport { CullingVolume as default };","map":null,"metadata":{},"sourceType":"module"}