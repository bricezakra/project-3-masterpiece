{"ast":null,"code":"import { decodeRGB565, GL } from '@loaders.gl/math';\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  var batchIds = tile.batchIds,\n      isRGB565 = tile.isRGB565,\n      pointCount = tile.pointCount;\n\n  if (batchIds && batchTable) {\n    var colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (var i = 0; i < pointCount; i++) {\n      var batchId = batchIds[i];\n      var dimensions = batchTable.getProperty(batchId, 'dimensions');\n      var color = dimensions.map(function (d) {\n        return d * 255;\n      });\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (isRGB565) {\n    var _colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (var _i = 0; _i < pointCount; _i++) {\n      var _color = decodeRGB565(colors[_i]);\n\n      _colorArray[_i * 3] = _color[0];\n      _colorArray[_i * 3 + 1] = _color[1];\n      _colorArray[_i * 3 + 2] = _color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: _colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}","map":null,"metadata":{},"sourceType":"module"}