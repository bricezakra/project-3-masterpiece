{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3 } from 'math.gl';\nimport { Intersect } from '../constants';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar AxisAlignedBoundingBox = function () {\n  function AxisAlignedBoundingBox() {\n    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, AxisAlignedBoundingBox);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.minimum = new Vector3(minimum);\n    this.maximum = new Vector3(maximum);\n    this.center = new Vector3(center);\n  }\n\n  _createClass(AxisAlignedBoundingBox, [{\n    key: \"fromPoints\",\n    value: function fromPoints(positions) {\n      if (!positions || positions.length === 0) {\n        this.minimum.set(0, 0, 0);\n        this.maximum.set(0, 0, 0);\n        this.center.set(0, 0, 0);\n        return this;\n      }\n\n      var minimumX = positions[0][0];\n      var minimumY = positions[0][1];\n      var minimumZ = positions[0][2];\n      var maximumX = positions[0][0];\n      var maximumY = positions[0][1];\n      var maximumZ = positions[0][2];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var p = _step.value;\n          var x = p[0];\n          var y = p[1];\n          var z = p[2];\n          minimumX = Math.min(x, minimumX);\n          maximumX = Math.max(x, maximumX);\n          minimumY = Math.min(y, minimumY);\n          maximumY = Math.max(y, maximumY);\n          minimumZ = Math.min(z, minimumZ);\n          maximumZ = Math.max(z, maximumZ);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.minimum.set(minimumX, minimumY, minimumZ);\n      this.maximum.set(maximumX, maximumY, maximumZ);\n      this.center.copy(this.minimum).add(this.maximum).scale(0.5);\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);\n      var normal = scratchNormal.from(plane.normal);\n      var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n      var s = this.center.dot(normal) + plane.distance;\n\n      if (s - e > 0) {\n        return Intersect.INSIDE;\n      }\n\n      if (s + e < 0) {\n        return Intersect.OUTSIDE;\n      }\n\n      return Intersect.INTERSECTING;\n    }\n  }]);\n\n  return AxisAlignedBoundingBox;\n}();\n\nexport { AxisAlignedBoundingBox as default };","map":null,"metadata":{},"sourceType":"module"}