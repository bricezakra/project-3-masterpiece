{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _GL_TYPE_TO_ARRAY_TYP;\n\nimport { GL_TYPE as GL } from '../constants';\nvar GL_TYPE_TO_ARRAY_TYPE = (_GL_TYPE_TO_ARRAY_TYP = {}, _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.DOUBLE, Float64Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.FLOAT, Float32Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.UNSIGNED_SHORT, Uint16Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.UNSIGNED_INT, Uint32Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.UNSIGNED_BYTE, Uint8Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.BYTE, Int8Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.SHORT, Int16Array), _defineProperty(_GL_TYPE_TO_ARRAY_TYP, GL.INT, Int32Array), _GL_TYPE_TO_ARRAY_TYP);\nvar NAME_TO_GL_TYPE = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nvar ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n\nvar GLType = function () {\n  function GLType() {\n    _classCallCheck(this, GLType);\n  }\n\n  _createClass(GLType, null, [{\n    key: \"fromTypedArray\",\n    value: function fromTypedArray(arrayOrType) {\n      arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n\n      for (var glType in GL_TYPE_TO_ARRAY_TYPE) {\n        var ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n        if (ArrayType === arrayOrType) {\n          return glType;\n        }\n      }\n\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n  }, {\n    key: \"fromName\",\n    value: function fromName(name) {\n      var glType = NAME_TO_GL_TYPE[name];\n\n      if (!glType) {\n        throw new Error(ERR_TYPE_CONVERSION);\n      }\n\n      return glType;\n    }\n  }, {\n    key: \"getArrayType\",\n    value: function getArrayType(glType) {\n      var clamped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      switch (glType) {\n        case GL.UNSIGNED_SHORT_5_6_5:\n        case GL.UNSIGNED_SHORT_4_4_4_4:\n        case GL.UNSIGNED_SHORT_5_5_5_1:\n          return Uint16Array;\n\n        default:\n          var ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n          if (!ArrayType) {\n            throw new Error(ERR_TYPE_CONVERSION);\n          }\n\n          return ArrayType;\n      }\n    }\n  }, {\n    key: \"getByteSize\",\n    value: function getByteSize(glType) {\n      var ArrayType = GLType.getArrayType(glType);\n      return ArrayType.BYTES_PER_ELEMENT;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(glType) {\n      return Boolean(GLType.getArrayType(glType));\n    }\n  }, {\n    key: \"createTypedArray\",\n    value: function createTypedArray(glType, buffer) {\n      var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var length = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (length === undefined) {\n        length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n      }\n\n      var ArrayType = GLType.getArrayType(glType);\n      return new ArrayType(buffer, byteOffset, length);\n    }\n  }]);\n\n  return GLType;\n}();\n\nexport { GLType as default };","map":null,"metadata":{},"sourceType":"module"}