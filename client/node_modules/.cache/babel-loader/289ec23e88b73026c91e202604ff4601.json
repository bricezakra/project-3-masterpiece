{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { S2 } from 's2-geometry';\nimport Long from 'long';\n\nfunction getIdFromToken(token) {\n  var paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nvar RADIAN_TO_DEGREE = 180 / Math.PI;\nvar MAX_RESOLUTION = 100;\n\nfunction XYZToLngLat(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      x = _ref2[0],\n      y = _ref2[1],\n      z = _ref2[2];\n\n  var lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n  var lng = Math.atan2(y, x);\n  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\n\nfunction getGeoBounds(_ref3) {\n  var face = _ref3.face,\n      ij = _ref3.ij,\n      level = _ref3.level;\n  var result = [];\n  var offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  var resolution = Math.max(1, MAX_RESOLUTION * Math.pow(2, -level));\n\n  for (var i = 0; i < 4; i++) {\n    var offset = offsets[i].slice(0);\n    var nextOffset = offsets[i + 1];\n    var stepI = (nextOffset[0] - offset[0]) / resolution;\n    var stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (var j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      var st = S2.IJToST(ij, level, offset);\n      var uv = S2.STToUV(st);\n      var xyz = S2.FaceUVToXYZ(face, uv);\n      result.push(XYZToLngLat(xyz));\n    }\n  }\n\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      return token;\n    }\n\n    token = getIdFromToken(token);\n  }\n\n  return S2.S2Cell.toHilbertQuadkey(token.toString());\n}\nexport function getS2Polygon(token) {\n  var key = getS2QuadKey(token);\n  var s2cell = S2.S2Cell.FromHilbertQuadKey(key);\n  return getGeoBounds(s2cell);\n}","map":null,"metadata":{},"sourceType":"module"}