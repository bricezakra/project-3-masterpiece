{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Matrix4, Vector3 } from 'math.gl';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from 'probe.gl';\nimport { path } from '@loaders.gl/core';\nimport assert from '../utils/assert';\nimport RequestScheduler from '../request-utils/request-scheduler';\nimport { calculateTransformProps } from './helpers/transform-utils';\nimport Tile3DHeader from './tile-3d-header';\nimport Tileset3DTraverser from './tileset-3d-traverser';\nimport Tileset3DCache from './tileset-3d-cache';\nvar TILES_TOTAL = 'Tiles In Tileset(s)';\nvar TILES_IN_MEMORY = 'Tiles In Memory';\nvar TILES_IN_VIEW = 'Tiles In View';\nvar TILES_RENDERABLE = 'Tiles To Render';\nvar TILES_LOADED = 'Tiles Loaded';\nvar TILES_LOADING = 'Tiles Loading';\nvar TILES_UNLOADED = 'Tiles Unloaded';\nvar TILES_LOAD_FAILED = 'Failed Tile Loads';\nvar POINTS_COUNT = 'Points';\nvar TILES_GPU_MEMORY = 'Tile Memory Use';\nvar WGS84_RADIUS_X = 6378137.0;\nvar WGS84_RADIUS_Y = 6378137.0;\nvar WGS84_RADIUS_Z = 6356752.3142451793;\n\nfunction getZoom(boundingVolume) {\n  var halfAxes = boundingVolume.halfAxes,\n      radius = boundingVolume.radius,\n      width = boundingVolume.width,\n      height = boundingVolume.height;\n\n  if (halfAxes) {\n    var _halfAxes = _slicedToArray(halfAxes, 9),\n        x = _halfAxes[0],\n        y = _halfAxes[4],\n        z = _halfAxes[8];\n\n    var zoomX = Math.log2(WGS84_RADIUS_X / x / 2);\n    var zoomY = Math.log2(WGS84_RADIUS_Y / y / 2);\n    var zoomZ = Math.log2(WGS84_RADIUS_Z / z / 2);\n    return (zoomX + zoomY + zoomZ) / 3;\n  } else if (radius) {\n    return Math.log2(WGS84_RADIUS_Z / radius);\n  } else if (height && width) {\n    var _zoomX = Math.log2(WGS84_RADIUS_X / width);\n\n    var _zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (_zoomX + _zoomY) / 2;\n  }\n\n  return 18;\n}\n\nvar DEFAULT_OPTIONS = {\n  basePath: '',\n  ellipsoid: Ellipsoid.WGS84,\n  modelMatrix: new Matrix4(),\n  throttleRequests: false,\n  maximumScreenSpaceError: 16,\n  maximumMemoryUsage: 32,\n  dynamicScreenSpaceError: false,\n  dynamicScreenSpaceErrorDensity: 0.00278,\n  dynamicScreenSpaceErrorFactor: 4.0,\n  skipLevelOfDetail: false,\n  baseScreenSpaceError: 1024,\n  onTileLoad: function onTileLoad() {},\n  onTileUnload: function onTileUnload() {},\n  onTileLoadFail: function onTileLoadFail(tile, message, url) {\n    return console.error(\"A 3D tile failed to load: \".concat(url, \" \").concat(message));\n  }\n};\n\nfunction getQueryParamString(queryParams) {\n  var queryParamStrings = [];\n\n  for (var _i = 0, _Object$keys = Object.keys(queryParams); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    queryParamStrings.push(\"\".concat(key, \"=\").concat(queryParams[key]));\n  }\n\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n\n    case 1:\n      return \"?\".concat(queryParamStrings[0]);\n\n    default:\n      return \"?\".concat(queryParamStrings.join('&'));\n  }\n}\n\nvar Tileset3D = function () {\n  function Tileset3D(json, url) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Tileset3D);\n\n    assert(json);\n    this.options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);\n    this.url = url;\n    this.basePath = path.dirname(url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.stats = new Stats({\n      id: url\n    });\n\n    this._initializeStats();\n\n    this.gpuMemoryUsageInBytes = 0;\n    this.geometricError = undefined;\n    this.userData = {};\n    this._queryParams = {};\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests\n    });\n    this._traverser = new Tileset3DTraverser();\n    this._cache = new Tileset3DCache();\n    this._processingQueue = [];\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this._selectedTilesToStyle = [];\n    this.asset = {};\n    this.credits = {};\n    this._root = undefined;\n    this._properties = undefined;\n    this._extensionsUsed = undefined;\n    this._gltfUpAxis = undefined;\n    this._loadTimestamp = undefined;\n    this._timeSinceLoad = 0.0;\n    this._updatedVisibilityFrame = 0;\n    this._extras = undefined;\n    this._allTilesAdditive = true;\n    this._hasMixedContent = false;\n    this._maximumScreenSpaceError = options.maximumScreenSpaceError;\n    this._maximumMemoryUsage = options.maximumMemoryUsage;\n    this._tilesLoaded = false;\n    this._initialTilesLoaded = false;\n    this._readyPromise = Promise.resolve();\n    this._classificationType = this.options.classificationType;\n    this._ellipsoid = this.options.ellipsoid;\n    this._dynamicScreenSpaceErrorComputedDensity = 0.0;\n\n    this._initializeTileSet(json, this.options);\n  }\n\n  _createClass(Tileset3D, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._destroy();\n    }\n  }, {\n    key: \"getTileUrl\",\n    value: function getTileUrl(tilePath, basePath) {\n      var isDataUrl = function isDataUrl(url) {\n        return url.startsWith('data:');\n      };\n\n      return isDataUrl(tilePath) ? tilePath : \"\".concat(basePath || this.basePath, \"/\").concat(tilePath).concat(this.queryParams);\n    }\n  }, {\n    key: \"hasExtension\",\n    value: function hasExtension(extensionName) {\n      return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n    }\n  }, {\n    key: \"update\",\n    value: function update(frameState) {\n      this._updatedVisibilityFrame++;\n\n      this._cache.reset();\n\n      this._traverser.traverse(this.root, frameState, this.options);\n\n      Object.assign(this, this._traverser.result);\n      var requestedTiles = this._requestedTiles;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = requestedTiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tile = _step.value;\n\n          this._loadTile(tile);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._unloadTiles();\n\n      var tilesRenderable = 0;\n      var pointsRenderable = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.selectedTiles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _tile = _step2.value;\n\n          if (_tile.contentAvailable) {\n            tilesRenderable++;\n\n            if (_tile.content.pointCount) {\n              pointsRenderable += _tile.content.pointCount;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n      this.stats.get(POINTS_COUNT).count = pointsRenderable;\n    }\n  }, {\n    key: \"trimLoadedTiles\",\n    value: function trimLoadedTiles() {\n      this._cache.trim();\n    }\n  }, {\n    key: \"addTileToCache\",\n    value: function addTileToCache(tile) {\n      this._cache.add(this, tile, function (tileset, tileToAdd) {\n        return tileset._addTileToCache(tileToAdd);\n      });\n    }\n  }, {\n    key: \"_initializeTileSet\",\n    value: function _initializeTileSet(tilesetJson, options) {\n      this.asset = tilesetJson.asset;\n\n      if (!this.asset) {\n        throw new Error('Tileset must have an asset property.');\n      }\n\n      if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n        throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n      }\n\n      if ('tilesetVersion' in this.asset) {\n        this._queryParams.v = this.asset.tilesetVersion;\n      }\n\n      this.credits = {\n        attributions: options.attributions || []\n      };\n      this._properties = tilesetJson.properties;\n      this.geometricError = tilesetJson.geometricError;\n      this._extensionsUsed = tilesetJson.extensionsUsed;\n      this._extras = tilesetJson.extras;\n      this._root = this._initializeTileHeaders(tilesetJson, null, this.basePath);\n\n      this._calculateViewProps();\n    }\n  }, {\n    key: \"_calculateViewProps\",\n    value: function _calculateViewProps() {\n      var root = this._root;\n      var center = root.boundingVolume.center;\n\n      if (!center) {\n        console.warn('center was not pre-calculated for the root tile');\n        this.cartographicCenter = new Vector3();\n        this.zoom = 16;\n        return;\n      }\n\n      this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n      this.zoom = getZoom(root.boundingVolume);\n    }\n  }, {\n    key: \"_initializeStats\",\n    value: function _initializeStats() {\n      this.stats.get(TILES_TOTAL);\n      this.stats.get(TILES_LOADING);\n      this.stats.get(TILES_IN_MEMORY);\n      this.stats.get(TILES_IN_VIEW);\n      this.stats.get(TILES_RENDERABLE);\n      this.stats.get(TILES_LOADED);\n      this.stats.get(TILES_UNLOADED);\n      this.stats.get(TILES_LOAD_FAILED);\n      this.stats.get(POINTS_COUNT, 'memory');\n      this.stats.get(TILES_GPU_MEMORY, 'memory');\n    }\n  }, {\n    key: \"_initializeTileHeaders\",\n    value: function _initializeTileHeaders(tilesetJson, parentTileHeader, basePath) {\n      var rootTile = new Tile3DHeader(this, tilesetJson.root, parentTileHeader, basePath);\n\n      if (parentTileHeader) {\n        parentTileHeader.children.push(rootTile);\n        rootTile._depth = parentTileHeader._depth + 1;\n      }\n\n      var stack = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        this.stats.get(TILES_TOTAL).incrementCount();\n        var children = tile._header.children || [];\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var childHeader = _step3.value;\n            var childTile = new Tile3DHeader(this, childHeader, tile, basePath);\n            tile.children.push(childTile);\n            childTile._depth = tile._depth + 1;\n            stack.push(childTile);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      return rootTile;\n    }\n  }, {\n    key: \"_destroyTileHeaders\",\n    value: function _destroyTileHeaders(parentTile) {\n      this._destroySubtree(parentTile);\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile) {\n        var loaded;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.stats.get(TILES_LOADING).incrementCount();\n                _context.prev = 1;\n                _context.next = 4;\n                return tile.loadContent();\n\n              case 4:\n                loaded = _context.sent;\n                _context.next = 13;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](1);\n                this.stats.get(TILES_LOADING).decrementCount();\n                this.stats.get(TILES_LOAD_FAILED).incrementCount();\n                this.options.onTileLoadFail(tile, _context.t0.message || _context.t0.toString(), tile.url);\n                return _context.abrupt(\"return\");\n\n              case 13:\n                this.stats.get(TILES_LOADING).decrementCount();\n\n                if (loaded) {\n                  _context.next = 16;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 16:\n                if (tile && tile._content) {\n                  calculateTransformProps(tile, tile._content);\n                }\n\n                this.options.onTileLoad(tile);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 7]]);\n      }));\n\n      function _loadTile(_x) {\n        return _loadTile2.apply(this, arguments);\n      }\n\n      return _loadTile;\n    }()\n  }, {\n    key: \"_addTileToCache\",\n    value: function _addTileToCache(tile) {\n      this.stats.get(TILES_LOADED).incrementCount();\n      this.stats.get(TILES_IN_MEMORY).incrementCount();\n      this.gpuMemoryUsageInBytes += tile._content.byteLength || 0;\n      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n    }\n  }, {\n    key: \"_unloadTile\",\n    value: function _unloadTile(tile) {\n      this.stats.get(TILES_IN_MEMORY).decrementCount();\n      this.stats.get(TILES_UNLOADED).incrementCount();\n      this.gpuMemoryUsageInBytes -= tile._content.byteLength || 0;\n      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n      this.options.onTileUnload(tile);\n      tile.unloadContent();\n    }\n  }, {\n    key: \"_unloadTiles\",\n    value: function _unloadTiles() {\n      this._cache.unloadTiles(this, function (tileset, tile) {\n        return tileset._unloadTile(tile);\n      });\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      var stack = [];\n\n      if (this._root) {\n        stack.push(this._root);\n      }\n\n      while (stack.length > 0) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = tile.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var child = _step4.value;\n            stack.push(child);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        var tile = stack.pop();\n        tile.destroy();\n      }\n\n      this._root = null;\n    }\n  }, {\n    key: \"_destroySubtree\",\n    value: function _destroySubtree(tile) {\n      var root = tile;\n      var stack = [];\n      stack.push(root);\n\n      while (stack.length > 0) {\n        tile = stack.pop();\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = tile.children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var child = _step5.value;\n            stack.push(child);\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n              _iterator5[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        if (tile !== root) {\n          this._destroyTile(tile);\n        }\n      }\n\n      root.children = [];\n    }\n  }, {\n    key: \"_destroyTile\",\n    value: function _destroyTile(tile) {\n      this._cache.unloadTile(this, tile);\n\n      this._unloadTile(tile);\n\n      tile.destroy();\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return this._properties;\n    }\n  }, {\n    key: \"ready\",\n    get: function get() {\n      return Boolean(this._root);\n    }\n  }, {\n    key: \"readyPromise\",\n    get: function get() {\n      return this._readyPromise.promise;\n    }\n  }, {\n    key: \"tilesLoaded\",\n    get: function get() {\n      return this._tilesLoaded;\n    }\n  }, {\n    key: \"queryParams\",\n    get: function get() {\n      return getQueryParamString(this._queryParams);\n    }\n  }, {\n    key: \"root\",\n    get: function get() {\n      return this._root;\n    }\n  }, {\n    key: \"boundingSphere\",\n    get: function get() {\n      this._checkReady();\n\n      this._root.updateTransform(this.modelMatrix);\n\n      return this._root.boundingSphere;\n    }\n  }, {\n    key: \"timeSinceLoad\",\n    get: function get() {\n      return this._timeSinceLoad;\n    }\n  }, {\n    key: \"maximumMemoryUsage\",\n    get: function get() {\n      return this._maximumMemoryUsage;\n    },\n    set: function set(value) {\n      assert(value > 0);\n      this._maximumMemoryUsage = value;\n    }\n  }, {\n    key: \"ellipsoid\",\n    get: function get() {\n      return this.options.ellipsoid;\n    }\n  }, {\n    key: \"extras\",\n    get: function get() {\n      return this._extras;\n    }\n  }]);\n\n  return Tileset3D;\n}();\n\nexport { Tileset3D as default };","map":null,"metadata":{},"sourceType":"module"}