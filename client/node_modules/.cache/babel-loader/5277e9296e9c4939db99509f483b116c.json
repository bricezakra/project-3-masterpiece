{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { Tileset3D, _getIonTilesetMetadata } from '@loaders.gl/3d-tiles';\nimport { getFrameState } from './get-frame-state';\nvar defaultProps = {\n  getPointColor: [0, 0, 0],\n  pointSize: 1.0,\n  opacity: 1.0,\n  data: null,\n  _ionAssetId: null,\n  _ionAccessToken: null,\n  loadOptions: {\n    throttleRequests: true\n  },\n  onTilesetLoad: function onTilesetLoad(tileset3d) {},\n  onTileLoad: function onTileLoad(tileHeader) {},\n  onTileUnload: function onTileUnload(tileHeader) {},\n  onTileLoadFail: function onTileLoadFail(tile, message, url) {}\n};\n\nvar Tile3DLayer = function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tile3DLayer).apply(this, arguments));\n  }\n\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        layerMap: {},\n        tileset3d: null\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function () {\n      var _updateState = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(_ref2) {\n        var props, oldProps, tileset3d;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                props = _ref2.props, oldProps = _ref2.oldProps;\n\n                if (!(props.data && props.data !== oldProps.data)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 4;\n                return this._loadTileset(props.data);\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                if (!((props._ionAccessToken || props._ionAssetId) && (props._ionAccessToken !== oldProps._ionAccessToken || props._ionAssetId !== oldProps._ionAssetId))) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return this._loadTilesetFromIon(props._ionAccessToken, props._ionAssetId);\n\n              case 9:\n                tileset3d = this.state.tileset3d;\n                _context.next = 12;\n                return this._updateTileset(tileset3d);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateState(_x) {\n        return _updateState.apply(this, arguments);\n      }\n\n      return updateState;\n    }()\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(tilesetUrl, fetchOptions, ionMetadata) {\n        var _this = this;\n\n        var response, tilesetJson, loadOptions, tileset3d;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return fetch(tilesetUrl, fetchOptions);\n\n              case 2:\n                response = _context2.sent;\n                _context2.next = 5;\n                return response.json();\n\n              case 5:\n                tilesetJson = _context2.sent;\n                loadOptions = this.getLoadOptions();\n                tileset3d = new Tileset3D(tilesetJson, tilesetUrl, _objectSpread({\n                  onTileLoad: function onTileLoad(tileHeader) {\n                    _this.props.onTileLoad(tileHeader);\n\n                    _this._updateTileset(tileset3d);\n\n                    _this.setNeedsUpdate();\n                  },\n                  onTileUnload: this.props.onTileUnload,\n                  onTileLoadFail: this.props.onTileLoadFail,\n                  fetchOptions: fetchOptions\n                }, ionMetadata, {}, loadOptions));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n\n                if (tileset3d) {\n                  this.props.onTilesetLoad(tileset3d);\n                }\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _loadTileset(_x2, _x3, _x4) {\n        return _loadTileset2.apply(this, arguments);\n      }\n\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_loadTilesetFromIon\",\n    value: function () {\n      var _loadTilesetFromIon2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(ionAccessToken, ionAssetId) {\n        var ionMetadata, url, headers;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _getIonTilesetMetadata(ionAccessToken, ionAssetId);\n\n              case 2:\n                ionMetadata = _context3.sent;\n                url = ionMetadata.url, headers = ionMetadata.headers;\n                _context3.next = 6;\n                return this._loadTileset(url, {\n                  headers: headers\n                }, ionMetadata);\n\n              case 6:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _loadTilesetFromIon(_x5, _x6) {\n        return _loadTilesetFromIon2.apply(this, arguments);\n      }\n\n      return _loadTilesetFromIon;\n    }()\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(tileset3d) {\n      var _this$context = this.context,\n          timeline = _this$context.timeline,\n          viewport = _this$context.viewport;\n\n      if (!timeline || !viewport || !tileset3d) {\n        return;\n      }\n\n      var frameState = getFrameState(viewport, Date.now());\n      tileset3d.update(frameState);\n\n      this._updateLayerMap(frameState.frameNumber);\n    }\n  }, {\n    key: \"_updateLayerMap\",\n    value: function _updateLayerMap(frameNumber) {\n      var _this$state = this.state,\n          tileset3d = _this$state.tileset3d,\n          layerMap = _this$state.layerMap;\n      var selectedTiles = tileset3d.selectedTiles;\n      var tilesWithoutLayer = selectedTiles.filter(function (tile) {\n        return !layerMap[tile.fullUri];\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tilesWithoutLayer[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tile = _step.value;\n          tileset3d.addTileToCache(tile);\n          layerMap[tile.fullUri] = {\n            layer: this._create3DTileLayer(tile),\n            tile: tile\n          };\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._selectLayers(frameNumber);\n    }\n  }, {\n    key: \"_selectLayers\",\n    value: function _selectLayers(frameNumber) {\n      var layerMap = this.state.layerMap;\n      var layerMapValues = Object.values(layerMap);\n\n      for (var _i = 0, _layerMapValues = layerMapValues; _i < _layerMapValues.length; _i++) {\n        var value = _layerMapValues[_i];\n        var tile = value.tile;\n        var layer = value.layer;\n\n        if (tile.selectedFrame === frameNumber) {\n          if (layer && layer.props && !layer.props.visible) {\n            layer = layer.clone({\n              visible: true\n            });\n            layerMap[tile.fullUri].layer = layer;\n          }\n        } else if (tile.contentUnloaded) {\n          delete layerMap[tile.fullUri];\n        } else if (layer && layer.props && layer.props.visible) {\n          layer = layer.clone({\n            visible: false\n          });\n          layerMap[tile.fullUri].layer = layer;\n        }\n      }\n\n      this.setState({\n        layers: Object.values(layerMap).map(function (layer) {\n          return layer.layer;\n        })\n      });\n    }\n  }, {\n    key: \"_create3DTileLayer\",\n    value: function _create3DTileLayer(tileHeader) {\n      if (!tileHeader.content) {\n        return null;\n      }\n\n      switch (tileHeader.content.type) {\n        case 'pnts':\n          return this._createPointCloudTileLayer(tileHeader);\n\n        case 'i3dm':\n        case 'b3dm':\n          return this._create3DModelTileLayer(tileHeader);\n\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_create3DModelTileLayer\",\n    value: function _create3DModelTileLayer(tileHeader) {\n      var _tileHeader$content = tileHeader.content,\n          gltf = _tileHeader$content.gltf,\n          instances = _tileHeader$content.instances,\n          cartographicOrigin = _tileHeader$content.cartographicOrigin,\n          modelMatrix = _tileHeader$content.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.fullUri),\n        data: instances || [{}],\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        _composeModelMatrix: true,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: function getPosition(instance) {\n          return [0, 0, 0];\n        }\n      });\n    }\n  }, {\n    key: \"_createPointCloudTileLayer\",\n    value: function _createPointCloudTileLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n          attributes = _tileHeader$content2.attributes,\n          pointCount = _tileHeader$content2.pointCount,\n          constantRGBA = _tileHeader$content2.constantRGBA,\n          cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n          modelMatrix = _tileHeader$content2.modelMatrix;\n      var positions = attributes.positions,\n          normals = attributes.normals,\n          colors = attributes.colors;\n\n      if (!positions) {\n        return null;\n      }\n\n      var _this$props = this.props,\n          pointSize = _this$props.pointSize,\n          getPointColor = _this$props.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.fullUri),\n        data: {\n          header: {\n            vertexCount: pointCount\n          },\n          attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            COLOR_0: colors\n          }\n        },\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this.state.layers;\n    }\n  }]);\n\n  return Tile3DLayer;\n}(CompositeLayer);\n\nexport { Tile3DLayer as default };\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}