{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer, fp64LowPart } from '@deck.gl/core';\nimport { Model, CubeGeometry, PhongMaterial, fp64 as fp64ShaderModule } from '@luma.gl/core';\nvar defaultMaterial = new PhongMaterial();\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './gpu-grid-cell-layer-vertex.glsl';\nimport fs from './gpu-grid-cell-layer-fragment.glsl';\nvar COLOR_DATA_UBO_INDEX = 0;\nvar ELEVATION_DATA_UBO_INDEX = 1;\nvar defaultProps = {\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  gridSize: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  gridOrigin: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  gridOffset: {\n    type: 'array',\n    min: 0,\n    value: [0, 0]\n  },\n  cellSize: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 1000\n  },\n  offset: {\n    type: 'array',\n    min: 0,\n    value: [1, 1]\n  },\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  extruded: true,\n  material: defaultMaterial\n};\n\nvar GPUGridCellLayer = function (_Layer) {\n  _inherits(GPUGridCellLayer, _Layer);\n\n  function GPUGridCellLayer() {\n    _classCallCheck(this, GPUGridCellLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GPUGridCellLayer).apply(this, arguments));\n  }\n\n  _createClass(GPUGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(GPUGridCellLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: ['project32', 'gouraud-lighting', 'picking', fp64ShaderModule]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        colors: {\n          size: 4,\n          update: this.calculateColors,\n          noAlloc: true\n        },\n        elevations: {\n          size: 4,\n          update: this.calculateElevations,\n          noAlloc: true\n        }\n      });\n\n      var model = this._getModel(gl);\n\n      this._setupUniformBuffer(model);\n\n      this.setState({\n        model: model\n      });\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new CubeGeometry(),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var _this$props = this.props,\n          data = _this$props.data,\n          cellSize = _this$props.cellSize,\n          offset = _this$props.offset,\n          extruded = _this$props.extruded,\n          elevationScale = _this$props.elevationScale,\n          coverage = _this$props.coverage,\n          gridSize = _this$props.gridSize,\n          gridOrigin = _this$props.gridOrigin,\n          gridOffset = _this$props.gridOffset,\n          elevationRange = _this$props.elevationRange;\n      var gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n      var gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n      var domainUniforms = this.getDomainUniforms();\n      var uniformBuffers = {\n        colorMaxMinBuffer: data.color.maxMinBuffer,\n        elevationMaxMinBuffer: data.elevation.maxMinBuffer\n      };\n      var colorRange = colorRangeToFlatArray(this.props.colorRange);\n      this.bindUniformBuffers(uniformBuffers);\n      this.state.model.setUniforms(Object.assign({}, uniforms, domainUniforms, {\n        cellSize: cellSize,\n        offset: offset,\n        extruded: extruded,\n        elevationScale: elevationScale,\n        coverage: coverage,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        gridOriginLow: gridOriginLow,\n        gridOffset: gridOffset,\n        gridOffsetLow: gridOffsetLow,\n        colorRange: colorRange,\n        elevationRange: elevationRange\n      })).draw();\n      this.unbindUniformBuffers(uniformBuffers);\n    }\n  }, {\n    key: \"bindUniformBuffers\",\n    value: function bindUniformBuffers(_ref2) {\n      var colorMaxMinBuffer = _ref2.colorMaxMinBuffer,\n          elevationMaxMinBuffer = _ref2.elevationMaxMinBuffer;\n      colorMaxMinBuffer.bind({\n        target: 35345,\n        index: COLOR_DATA_UBO_INDEX\n      });\n      elevationMaxMinBuffer.bind({\n        target: 35345,\n        index: ELEVATION_DATA_UBO_INDEX\n      });\n    }\n  }, {\n    key: \"unbindUniformBuffers\",\n    value: function unbindUniformBuffers(_ref3) {\n      var colorMaxMinBuffer = _ref3.colorMaxMinBuffer,\n          elevationMaxMinBuffer = _ref3.elevationMaxMinBuffer;\n      colorMaxMinBuffer.unbind({\n        target: 35345,\n        index: COLOR_DATA_UBO_INDEX\n      });\n      elevationMaxMinBuffer.unbind({\n        target: 35345,\n        index: ELEVATION_DATA_UBO_INDEX\n      });\n    }\n  }, {\n    key: \"calculateColors\",\n    value: function calculateColors(attribute) {\n      var data = this.props.data;\n      attribute.update({\n        buffer: data.color.aggregationBuffer\n      });\n    }\n  }, {\n    key: \"calculateElevations\",\n    value: function calculateElevations(attribute) {\n      var data = this.props.data;\n      attribute.update({\n        buffer: data.elevation.aggregationBuffer\n      });\n    }\n  }, {\n    key: \"getDomainUniforms\",\n    value: function getDomainUniforms() {\n      var _this$props2 = this.props,\n          colorDomain = _this$props2.colorDomain,\n          elevationDomain = _this$props2.elevationDomain;\n      var domainUniforms = {};\n\n      if (colorDomain !== null) {\n        domainUniforms.colorDomainValid = true;\n        domainUniforms.colorDomain = colorDomain;\n      } else {\n        domainUniforms.colorDomainValid = false;\n      }\n\n      if (elevationDomain !== null) {\n        domainUniforms.elevationDomainValid = true;\n        domainUniforms.elevationDomain = elevationDomain;\n      } else {\n        domainUniforms.elevationDomainValid = false;\n      }\n\n      return domainUniforms;\n    }\n  }, {\n    key: \"_setupUniformBuffer\",\n    value: function _setupUniformBuffer(model) {\n      var gl = this.context.gl;\n      var programHandle = model.program.handle;\n      var colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n      var elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n      gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n      gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n    }\n  }]);\n\n  return GPUGridCellLayer;\n}(Layer);\n\nexport { GPUGridCellLayer as default };\nGPUGridCellLayer.layerName = 'GPUGridCellLayer';\nGPUGridCellLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}