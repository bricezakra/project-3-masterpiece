{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Vector3, Matrix3, Matrix4, Quaternion } from 'math.gl';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { parse3DTileGLTFViewSync, extractGLTF } from './helpers/parse-3d-tile-gltf-view';\nexport function parseInstancedModel3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\n\nfunction _parseInstancedModel3DTile() {\n  _parseInstancedModel3DTile = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n            _context.next = 3;\n            return extractGLTF(tile, tile.gltfFormat, options, context);\n\n          case 3:\n            return _context.abrupt(\"return\", byteOffset);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseInstancedModel3DTile.apply(this, arguments);\n}\n\nexport function parseInstancedModel3DTileSync(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n\n  if (tile.version !== 1) {\n    throw new Error(\"Instanced 3D Model version \".concat(tile.version, \" is not supported\"));\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  var view = new DataView(arrayBuffer);\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n  return byteOffset;\n}\n\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  var collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false,\n    url: undefined,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    forwardAxis: [1, 0, 0]\n  };\n  var instances = collectionOptions.instances;\n  var instancePosition = new Vector3();\n  var instanceNormalRight = new Vector3();\n  var instanceNormalUp = new Vector3();\n  var instanceNormalForward = new Vector3();\n  var instanceRotation = new Matrix3();\n  var instanceQuaternion = new Quaternion();\n  var instanceScale = new Vector3();\n  var instanceTranslationRotationScale = {};\n  var instanceTransform = new Matrix4();\n  var scratch1 = [];\n  var scratch2 = [];\n  var scratchVector1 = new Vector3();\n  var scratchVector2 = new Vector3();\n\n  for (var i = 0; i < instancesLength; i++) {\n    var position = void 0;\n\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n      var quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3, scratchVector1);\n\n      if (!quantizedVolumeOffset) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      var quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3, scratchVector2);\n\n      if (!quantizedVolumeScale) {\n        throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      var MAX_UNSIGNED_SHORT = 65535.0;\n\n      for (var j = 0; j < 3; j++) {\n        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    instanceTranslationRotationScale.translation = instancePosition;\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n    var hasCustomOrientation = false;\n\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, scratch1);\n      tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, scratch2);\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n    instanceScale.set(1.0, 1.0, 1.0);\n    var scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n\n    var nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    instanceTranslationRotationScale.scale = instanceScale;\n    var batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n\n    if (batchId === undefined) {\n      batchId = i;\n    }\n\n    var rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n    instanceTransform.identity();\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n    var modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix: modelMatrix,\n      batchId: batchId\n    };\n  }\n\n  tile.instances = instances;\n}","map":null,"metadata":{},"sourceType":"module"}