{"ast":null,"code":"import { Vector2, Vector3, clamp, _MathUtils } from 'math.gl';\nimport assert from '../utils/assert';\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\nvar scratchVector2 = new Vector2();\nvar scratchVector3 = new Vector3();\nvar scratchEncodeVector2 = new Vector2();\nvar octEncodeScratch = new Vector2();\nvar uint8ForceArray = new Uint8Array(1);\n\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n\nfunction fromSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n}\n\nfunction toSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\n\nexport function octEncodeInRange(vector, rangeMax, result) {\n  assert(vector);\n  assert(result);\n  var vector3 = scratchVector3.from(vector);\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n  return result;\n}\nexport function octEncode(vector, result) {\n  return octEncodeInRange(vector, 255, result);\n}\nexport function octEncodeToVector4(vector, result) {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\nexport function octDecodeInRange(x, y, rangeMax, result) {\n  assert(result);\n\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(\"x and y must be unsigned normalized integers between 0 and \".concat(rangeMax));\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\nexport function octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\nexport function octDecodeFromVector4(encoded, result) {\n  assert(encoded);\n  assert(result);\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\nexport function octPackFloat(encoded) {\n  var vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\nexport function octEncodeFloat(vector) {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\nexport function octDecodeFloat(value, result) {\n  assert(Number.isFinite(value));\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n  return octDecode(x, y, result);\n}\nexport function octPack(v1, v2, v3, result) {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n  var encoded1 = octEncodeFloat(v1);\n  var encoded2 = octEncodeFloat(v2);\n  var encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\nexport function octUnpack(packed, v1, v2, v3) {\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\nexport function compressTextureCoordinates(textureCoordinates) {\n  var x = textureCoordinates.x * 4095.0 | 0;\n  var y = textureCoordinates.y * 4095.0 | 0;\n  return 4096.0 * x + y;\n}\nexport function decompressTextureCoordinates(compressed, result) {\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n\n  function zigZagDecode(value) {\n    return value >> 1 ^ -(value & 1);\n  }\n\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}