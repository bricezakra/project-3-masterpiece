{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { PathLayer } from '@deck.gl/layers';\nimport { createIterable } from '@deck.gl/core';\nvar defaultProps = {\n  trailLength: {\n    type: 'number',\n    value: 120,\n    min: 0\n  },\n  currentTime: {\n    type: 'number',\n    value: 0,\n    min: 0\n  },\n  getTimestamps: {\n    type: 'accessor',\n    value: null\n  }\n};\n\nvar TripsLayer = function (_PathLayer) {\n  _inherits(TripsLayer, _PathLayer);\n\n  function TripsLayer() {\n    _classCallCheck(this, TripsLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TripsLayer).apply(this, arguments));\n  }\n\n  _createClass(TripsLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      var shaders = _get(_getPrototypeOf(TripsLayer.prototype), \"getShaders\", this).call(this);\n\n      shaders.inject = {\n        'vs:#decl': \"uniform float trailLength;\\nuniform bool isPath3D;\\nattribute vec2 instanceTimestamps;\\nvarying float vTime;\\n\",\n        'vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);': \"vec2 timestamps = instanceTimestamps;\\nif (!isPath3D) {\\n  prevPosition.z = 0.0;\\n  currPosition.z = 0.0;\\n  nextPosition.z = 0.0;\\n  timestamps.x = instanceStartPositions.z;\\n  timestamps.y = instanceEndPositions.z;\\n}\\n\",\n        'vs:#main-end': \"float shiftZ = sin(timestamps.x) * 1e-4;\\ngl_Position.z += shiftZ;\\nvTime = timestamps.x + (timestamps.y - timestamps.x) * vPathPosition.y / vPathLength;\\n\",\n        'fs:#decl': \"uniform float trailLength;\\nuniform float currentTime;\\nvarying float vTime;\\n\",\n        'fs:#main-start': \"if(vTime > currentTime || vTime < currentTime - trailLength) {\\n  discard;\\n}\\n\",\n        'fs:DECKGL_FILTER_COLOR': 'color.a *= 1.0 - (currentTime - vTime) / trailLength;'\n      };\n      return shaders;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(params) {\n      _get(_getPrototypeOf(TripsLayer.prototype), \"initializeState\", this).call(this, params);\n\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instanceTimestamps: {\n          size: 2,\n          update: this.calculateInstanceTimestamps\n        }\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(params) {\n      var _this$props = this.props,\n          trailLength = _this$props.trailLength,\n          currentTime = _this$props.currentTime,\n          getTimestamps = _this$props.getTimestamps;\n      params.uniforms = Object.assign({}, params.uniforms, {\n        trailLength: trailLength,\n        currentTime: currentTime,\n        isPath3D: Boolean(getTimestamps)\n      });\n\n      _get(_getPrototypeOf(TripsLayer.prototype), \"draw\", this).call(this, params);\n    }\n  }, {\n    key: \"calculateInstanceTimestamps\",\n    value: function calculateInstanceTimestamps(attribute, _ref) {\n      var startRow = _ref.startRow,\n          endRow = _ref.endRow;\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getTimestamps = _this$props2.getTimestamps;\n\n      if (!getTimestamps) {\n        attribute.constant = true;\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$state$pathTesse = this.state.pathTesselator,\n          bufferLayout = _this$state$pathTesse.bufferLayout,\n          instanceCount = _this$state$pathTesse.instanceCount;\n      var value = new Float32Array(instanceCount * 2);\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var i = 0;\n\n      for (var objectIndex = 0; objectIndex < startRow; objectIndex++) {\n        i += bufferLayout[objectIndex] * 2;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          objectInfo.index++;\n          var geometrySize = bufferLayout[objectInfo.index];\n          var timestamps = getTimestamps(object, objectInfo);\n\n          for (var j = 0; j < geometrySize; j++) {\n            value[i++] = timestamps[j];\n            value[i++] = timestamps[j + 1];\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      attribute.constant = false;\n      attribute.value = value;\n    }\n  }]);\n\n  return TripsLayer;\n}(PathLayer);\n\nexport { TripsLayer as default };\nTripsLayer.layerName = 'TripsLayer';\nTripsLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}